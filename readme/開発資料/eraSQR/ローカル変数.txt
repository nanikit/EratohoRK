이 문장은 프로그램 초심자의 7-153이 어딘지 모르게 파악한 로컬 변수에 대한 설명문입니다.
여러가지 잘못되어 있을 가능성이 있습니다.

로컬 변수란?

LOCAL, LOCAL:1, ~
ARG, ARG:1, ~
, eramaker에서는 사용하지 못하고 emuera 전용 구문의 1개이다.
사용법은 다른 변수, FLAG, TFLAG, CFLAG 등과 같아
	LOCAL = 5(LOCAL에 5를 대입)
	CFLAG:1 += LOCAL
라든지
	IF TALENT:ARG:0(ARG 번째의 캐릭터가 처녀일지 어떨지)
등 등.


LOCAL의 사용법
	이것들의 로컬 변수는, 함수간(@이하의 한묶음)에서의 수수를 할 수 없는, 이라고 하는 특징을 가지고 있다.
	통상의 변수, 예를 들면 FLAG라면
		@AAA
		FLAG:0 = 5
		CALL BBB

		@BBB
		FLAG:13 = FLAG:5

	(와)과 같이 CALL등으로 함수가 불려 가도 변수의 내용은 변함없이 그대로 사용할 수가 있다.
	이 때 FLAG:13 = 5이다

	한편 LOCAL는
		@AAA
		LOCAL = 5
		CALL BBB

		@BBB
		FLAG:13 = LOCAL

	그렇다고 하는 사용법은 할 수 없다@AAA로 LOCAL에 5를 대입해도@BBB에 LOCAL=5라고 하는 결과는 주고 받아지지 않기 때문에
	이 때 FLAG:13 = 0이다.

	이러한 거동을 하는 LOCAL는 계산 결과의 일시적인 보존 따위에 이용된다.
	eramaker에서는 그러한 처리는
		A = 5
	등과 같이 1문자 변수가 잘 이용되어 왔다.
	예를 들면 이 A에 벌써 숫자가 대입되고 있어 후의 처리로 그 수치를 이용한다고 하는 것이 있다면
	A에 수치를 대입할 수는 없는 다른 변수를 사용하지 않으면 안 된다.
	1문자 변수는 이러한이라고 해 그 거동을 파악하는 것이 귀찮지만, LOCAL라면 그 함수내만을
	주의하면 충분하므로, 이러한 가벼운 계산 처리라면 LOCAL를 이용해야 하는 것이다.

ARG의 사용법
	뭔가의 계산 결과를 다음의 함수에서도 사용하고 싶을 때, LOCAL에서는 이러한 처리는 할 수 없다.
	1문자 변수를 이용한다면
		@AAA
		A = 5
		CALL BBB

		@BBB
		IF TALENT:A:0
		~
	로 오지만, 상술한 대로 1문자 변수는 그 거동을 정확하게 파악하지 않으면 모처럼 보존한 수치를 파괴해 버릴지도 모른다.
	특히 CALL로 함수를 호출하거나 하고 있으면 만들고 있는 측도 이 1문자 변수를 이용해도 좋은 것인지 모르게 된다.
	이러한 가벼운 계산의 수수에 이용하는 것이 ARG이다.
		@AAA
		LOCAL = 5
		CALL BBB
	이대로는@BBB에서는 LOCAL = 5라고 하는 결과를 이용하는 것은 할 수 없다.
	거기서 emuera에서는
		@AAA
		LOCAL = 5
		CALL BBB(LOCAL)
	그렇다고 하는 처리를 한다. CALL BBB(LOCAL)란@BBB로 LOCAL = 5라고 하는 결과를 사용한다, 라고 하는 의미이다.
		@AAA
		LOCAL = 5
		CALL BBB(LOCAL)

		@BBB(ARG)
		IF TALENT:ARG:0
		~
	이러한 수치의 수수에 이용하는 것이 ARG이다. ↑의 구문에서는 CALL BBB(LOCAL)로@BBB에 LOCAL = 5라고 하는 결과를 ARG = 5
	로서 인도한다고 하는 처리를 실시하고 있다.
	이러한 처리는 복수의 변수에 대해 가능하고,
		@AAA
		LOCAL = 5
		LOCAL:1 = 10
		CALL BBB(LOCAL, LOCAL:1)

		@BBB(ARG, ARG:1)
		IF TALENT:ARG:0 || TALENT:(ARG:1):0
		~
	그렇다고 하는 구문에서는@AAA로부터@BBB를 호출할 때에 ARG = LOCAL, ARG:1 = LOCAL:1이라고 하는 처리가 더해지고 있다.

이상 SQR로 자주(잘) 보이는 LOCAL 변수의 해설이었습니다.
