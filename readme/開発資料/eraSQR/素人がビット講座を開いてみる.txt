@프로그램 초심자가 가르치는 비트 강좌

0. 이 문장을 읽는 것에 해당하는 제주의
이 문장은 기존의 비트 강좌를 읽었지만 의미를 모르는, 이라고 하는 사람을 대상으로 쓰여된 것입니다.
어떠한 상황으로 사용하면 좋은 것인지, 어떻게 사용하면 좋은 것인지, 라는 것을 중심으로 해설하고 있어, 비트 연산의 도리, 이론에 대해서는 그다지 접하고 있지 않습니다.

또 작자는 프로그램의 지식은 ERA를 만날 때까지 전무였으므로, 이 문장에는 많은 오해와 부적절한 표현이 포함되어 있을 것입니다. 그러므로, 비트 연산에 대해, 우선은 기존의 비트 강좌를 참고로 해 주세요.

1. 왜 비트 연산을 사용하는 것인가
	어느 플래그에 복수의 정보를 싣는 경우, 어떻게 하면 좋을까.
예를 들어 자지에 정액, 애액, 타액, 애널의 더러워져, 등이 부착하고 있는 모습을 나타내고 싶은 경우,
FLAG:1 = 1이라면 정액이 부착, FLAG:1 = 2라면 애액이 부착이라고 하는 것 같은 처리에서는 안된다.
왜냐하면 정액과 애액이 동시에 부착하고 있는 경우도 생각할 수 있기 때문이다.
동시에 부착하고 있는 경우,
FLAG:1 = 3이라면 정액과 애액이 동시에 부착하고 있는, 등이라고 정의하는 것은 가능하지만,
타액, 애널의 더러워져, 등등 요소가 증가하는 것에 따라 가속도적으로 처리가 번잡하게 되어, 효율적인 작업은 기대 할 수 없게 된다.

예를 들어
FLAG:1 = 1이라면 정액이 부착, 0이라면 정액은 부착하고 있지 않다
FLAG:2 = 1이라면 애액이…
등이라고 말하는 기술도 가능하겠지만, 비트를 사용하는 것으로 이 장황한 처리를 정리할 수가 있는 것이다.
------------------------------------------------------------------------------------------------
2. 비트 연산의 사용법
	많은 바리안트에서는 더러움은 STAIN라고 하는 변수로 관리하고 있다.
SQR에서는 MASTER의 자지의 더러움은 STAIN:MASTER:2라고 하는 변수에 격납되고 있다.
<례>
;부위
STAIN:0 =입
STAIN:1 =손
STAIN:2 =페니스　　　비고:조교 개시시에 페니스의 더러움이 부착(STAIN:X:2 = 2)
STAIN:3 =바기나　　비고:조교 개시시에 애액의 더러움이 부착  (STAIN:X:3 = 1)
STAIN:4 =애널　　　비고:조교 개시시에 애널의 더러움이 부착(STAIN:X:4 = 8)
STAIN:5 =가슴
STAIN:6 =다리

;더러움의 내용
※비트 연산 처리
1 =애액
2 =페니스
4 =정액
8 =애널
16=모유
32=피
64=점액

만약, MASTER의 자지에 애널의 더러움이 부착하는 것 같은 행동을 하면,|라고 하는 연산자를 이용해 그 정보를 STAIN:MASTER:2에 기입할 수가 있다.
	STAIN:MASTER:2 |= 8
피가 붙었다면
	STAIN:MASTER:2 |= 32
된다.
왜 8이나 64와 같은 2의 N승의 숫자를 이용할까는 다음에 해설한다.


|=라고 하는 연산자는 오해를 두려워하지 말고 말하면, 덧셈이다.
	STAIN:MASTER:2 |= 8
그렇다고 하는 식은
	STAIN:MASTER:2 += 8
생각해 받아도 괜찮다.

애널에 삽입하면 찢어져 피가 나왔을 경우는,
	STAIN:MASTER:2 |= 8
	STAIN:MASTER:2 |= 32
라고 계속해 기입하는 것으로, 애널의 더러움과 피가 부착하고 있는 정보를 자지에 격납할 수가 있다.

그런데, 자지가 더러워져 있을 때 조교 대상이 특정의 행동을 한다, 라고 하는 시추에이션을 상정 해 주었으면 한다.
이 때
	IF "자지가 더러워져 있습니다"
		PRINTL 자지가 더러워져 있으므로 입에 물고 싶지 않은 것 같다
	ENDIF
그렇다고 하는 것 같은 구문이 생각된다.

IF이하에 자지가 더러워져 있는지 어떤지를 판별하는 식을 넣을 필요가 있어, 이 때에 사용하는 연산자가&이다.
	IF STAIN:MASTER:2 & 8 > 0
		PRINTL 자지가 더러워져 있으므로 입에 물고 싶지 않은 것 같다
	ENDIF

만약 이전에
	STAIN:MASTER:2 |= 8
라고 자지에 애널의 더러움을 부착시켰다면,
	STAIN:MASTER:2 & 8
그렇다고 하는 식의 대답은정의 숫자가 된다. 즉
	STAIN:MASTER:2 & 8 > 0
이다.
또 STAIN:MASTER:2가 초기화되어 이후,
	STAIN:MASTER:2 |= 8
그렇다고 하는 식이 한번도 사용되지 않으면
	STAIN:MASTER:2 & 8 = 0
된다.

|(이)나&가 무엇을 하고 있는지는 여기에서는 접하지 않고 다음에 해설하기로 한다.

------------------------------------------------------------------------------------------------
3. 2 진수
	2 진수와는 0으로 1만으로 나타내진 숫자의 일이다. 평상시 우리가 사용하는 숫자는 10 진수이며, 2 진수와 10 진수는 이하의 관계에 있다.
10 진수	2 진수
0		0
1		1
2		10
3		11
4		100
5		101
6		110
7		111
8		1000
9		1001
10		1010
11		1011
12		1100
13		1101
14		1110
15		1111
16		10000
자세한 설명은 수학의 교과서에 양보하기로 해, 이하에 구문으로 이용하는데 있어서 편리한 2 진수의 가지는 성질을 보고 가기로 하자.

3-1. 10 진수와 2 진수
	위의 10 진수와 2 진수와의 대비를 보여 받고 싶다.
2 진수로 자리수가 오르는 숫자（1, 10, 100, 1000, 10000）를 10 진수로 나타내면 각각, 1, 2, 4, 8, 16이 된다.
즉 10 진수로 표시했을 때 2의 0승, 1승, 2승,… 이 될 때 2 진수에서는 자리수가 오른다.

3-2. 2 진수의 덧셈
	예를 들어 2 진수에 있어서의	10 + 110이라고 하는 덧셈을 생각해 본다. 10 진수로 표기하면 2 + 6이다.
물론 10 + 110 = 120이라고 하는 대답은 되지 않는다. 2 진수에서는 2라고 하는 숫자는 존재하지 않고, 융통 올라 10이 된다.
	  10
	+110
	-
필산한다고 대답의 1자리수째는 0, 2자리수째는 융통 올라 10, 3자리수째도 융통 올라 10인 것으로 대답은 1000이 된다.
10 진수로 표기하면 2 + 6은 물론 8인 것으로, 2 진수의 덧셈과 10 진수의 덧셈의 대답은 일치한다.

그런데, 비트 연산에서는 주로 2의 n승의 숫자의 덧셈(엄밀하게는 다르다)을 한다（라고 생각한다）.
<예-SQN의 플래그에 이용되는 비트>
CFLAG:467	임신 이벤트 플래그
& 64	임신 예정의 잠복 기간
& 128	임신 기간
& 256	출산 가까이&출산
& 512	육아
& 1024	위험일

예를 들어 4 + 8（2 진수 표기에서는 100 + 1000）를 생각해 보자.
	  100
	+1000
	-
	 1100
여기서 중요한 것은 2의 N승끼리의 덧셈에서는 융통 오름이 생기지 않는 것에 있다.
또 1 OR 0으로 생각하면, 4는 3자리수째에 1, 8은 4자리수째에 1이 있지만, 대답의 1100에 주목하면, 그 정보가 보존되고 있다.
------------------------------------------------------------------------------------------------
4. 비트 연산
	SQR에서는 맵 정보의 처리에 비트 연산을 사용하고 있다.
FLAG:1800 ~FLAG:1899에 10*10의 플로어의 각각 하나의 패널과 대응하고 있다.
예를 들어 FLAG:1800은 플로어의 제일 좌상, FLAG:1809에는 플로어의 제일 우상의 패널의 정보를 격납하고 있다.
패널에는, 장애물이 그 패널에 있을지 어떨지, MASTER가 그 패널에 있을까 않은가, 적이 있을지 어떨지, 아이템이 있을지 어떨지, 등의 정보가 격납되고 있다. 이것들의 정보를 하나의 플래그에 전부 담기 위해서(때문에) 비트 연산을 사용하고 있는 것으로 있다.

맵이 생성될 때 우선 최초로 플래그의 초기화, FLAG:1800 = 0, FLAG:1801 = 0,… 이라고 하는 처리를 하고 있다.
다음에 장애물이 설치된다. 적당한 플래그를 선택해, 예를 들어 맵의 제일 좌상이 선택되었다면
FLAG:1800 |= 1
그렇다고 하는 처리를 하고 있다. |=와는 덧셈 같은 것으로, 여기에서는 FLAG:1800 + 1(2의 0승) = 0 + 1으로 같은 처리를 하고 있다（물론 엄밀하게는 다르다）.

다음에 장애물이 놓여지지 않은 장소（있고 해 속에 있다）에 MASTER, 적, 아이템, 계단 따위가 설치된다.
예를 들어 맵의 좌상에 MASTER를 일어나고 싶다면
FLAG:1800 |= 4
그렇다고 하는 처리를 가한다.

전술한 것처럼, 비트 연산에서는 2의 N승의 덧셈을 한다.
같은 지점(플로어의 좌상)에 아이템을 일어나고 싶다면
FLAG:1800 |= 16이다.

이 때
FLAG:1800 |= 4는 FLAG:1800 = FLAG:1800 + 4 = 0 + 4 = 4
FLAG:1800 |= 16에서는 FLAG:1800 = FLAG:1800 + 16 = 4 + 16 = 20이라고 하는 처리를 하고 있다(라고 생각한다）.
이진수로 나타낸다면
4 + 16 = 100 + 10000 = 10100  이다.

4-1. 연산자&
	여기서 2의 N승끼리의 덧셈이라면, 조오름이 생기지 않는, 자리수의 정보가 보존되는, 라는 것을 생각해 내 받고 싶다.
자리수의 정보가 보존되고 있는 한, 10100의 3자리수째가 1인가 0인지를 판별하는 것으로 그 패널에 MASTER가 있을까 않은가, 라는 것을 판별할 수 있는 것이다.
어느 숫자가 있는 자리수가 0인가 1인지를 판별할 때에 이용하는 연산자가&이다.

예를 들어 20을 2 진수로 표시했을 때(10100)의 3자리수째가 1인가 0인지를 알고 싶을 때,
	20 & 4
그렇다고 하는 식을 이용한다. 20의 3자리수째는 1이며
	20 & 4 = 4 = 100(2 진수 표기)
된다.
	20 & 8
그렇다고 하는 식은 20의 4자리수째가 1인가 0인지를 판별하고 있어,
	20 & 8 = 0
된다.
이상과 같이,&를 이용한 식은, 어느 자리수가 1이라면 대답은 1이상의 값이 대답이 되어, 0이라면 대답은 0이 된다.

<례>
IF FLAG:M & 4 > 0 && FLAG:M & 16 > 0
	PRINTL 보물상자를 찾아냈다
	PRINTW 개정[開錠]을 시도합니까?

이 예는 있는 패널에 대응하는 FLAG의 수치의 3자리수째에 1, 5자리수째에 1이 있는 경우, 아래의 처리를 실시하는 명령이다.
물론 FLAG:M = 20이라면
	FLAG:M & 4 = 4 = 100 > 0
	FLAG:M & 16 = 16 = 10000 > 0
(이어)여서 이 명령은 실행된다.
또
	FLAG:M = 54(2 진수에서는 110110)
그렇지만 같이이다.

4-2. 연산자|
	조금 전부터|=는 덧셈이라면 좋은 계속해 왔지만, 저것은 거짓말이다. 잊어 줘.
FLAG:1800 = 6 = 110(2 진수 표기) 때,
FLAG:1800 |= 4 = 6 + 4 = 10 = 1010(2 진수 표기)은 되지 않는다.
	4  =  100
	10 = 1010
그래서, 그대로의 덧셈에서는 중요한 3자리수째의 정보가 보존되지 않는 것이 알고 계실 것이다.
실제로는
	  110
	| 100
	-
	  110
	 FLAG:1800 |= 6
이다(아마).

자세하게는 다른 해설에 양보한다고 하여,|를 사용한 연산에서는 자리수의 정보가 보존된다고 하는 것이 이해할 수 있으면 된다.
FLAG:1800 |= 4라고 하는 연산을 실시한 것이라면, 그 전후로|=를 사용해 어떤 계산을 하려고
FLAG:1800 & 4 = 4가 되는 것이다.

4-3. 비트를 지우고 싶을 때
	MASTER, 적의 이동했을 때 등, 원래의 위치의 FLAG를 그대로 해 두면, MASTER, 적의 분열이라고 하는 현상이 생겨 버린다.
그 때문에, FLAG의 소거를 실시할 필요가 있지만, 그걸 위해서는 뺄셈을 이용하고 있다(다른 방법이 있을지도 모른다).
<례>
			PRINTL 보물상자를 개정[開錠] 했다
			PRINTFORMW 개정[開錠] 경험 +{A}
			CALL DUNGEON_MOVE
			FLAG:M -= 16
이 때 FLAG:M로부터 10000을 빼는 것으로, FLAG:M의 5자리수째의 숫자를 0으로 하고 있는 것으로 있다.
여기서 주의하지 않으면 안 되는 것은, 원래 FLAG:M의 5자리수째가 0의 경우, 융통 내려감이 생겨 버려, 다른 비트에 영향을 주어 버릴 수도 있다.
이 경우, 5자리수째가 1인 것이 명백한 것으로 특별한 처리를 하고 있지 않지만,
SIF FLAG:M & 16 > 0
그렇다고 하는 것 같은 처리가 필요할 수도 있을 것이다.




